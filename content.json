[{"title":"阿里巴巴java开发命名风格","date":"2017-06-19T01:37:45.000Z","path":"2017/06/19/阿里巴巴java开发命名风格/","text":"【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。反例： name / __name / $Object / name / name$ / Object$ 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明： 正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3 【强制】 类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。正例： localValue / getHttpMessage() / inputUserId 【强制】 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例： MAX_STOCK_COUNT反例： MAX_COUNT 【强制】 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。 【强制】 中括号是数组类型的一部分，数组定义如下：String[] args;反例： 使用 String args[]的方式来定义。 【强制】 POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。反例： 定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是 isDeleted()，RPC框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。 【强制】 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考spring 的框架结构） 【强制】 杜绝完全不规范的缩写，避免望文不知义。反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【强制】 如果使用到了设计模式，建议在类名中体现出具体模式。说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。正例：public class OrderFactory;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class LoginProxy;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public class ResourceObserver; 【强制】 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。正例： 接口方法签名：void f();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口基础常量表示：String COMPANY = “alibaba”;反例： 接口方法定义：public abstract void f();说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 接口和实现类的命名有两套规则：1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。正例： CacheServiceImpl 实现 CacheService 接口。2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。正例： AbstractTranslator 实现 Translatable。 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例： 枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。 【参考】各层命名规约：A) Service/DAO 层方法命名规约 1） 获取单个对象的方法用 get 做前缀。 2） 获取多个对象的方法用 list 做前缀。 3） 获取统计值的方法用 count 做前缀。 4） 插入的方法用 save（推荐）或 insert 做前缀。 5） 删除的方法用 remove（推荐）或 delete 做前缀。 6） 修改的方法用 update 做前缀。 B) 领域模型命名规约 1） 数据对象：xxxDO，xxx 即为数据表名。 2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。 3） 展示对象：xxxVO，xxx 一般为网页名称。 4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。","tags":[{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"},{"name":"Java","slug":"Java","permalink":"http://wangxun.date/tags/Java/"},{"name":"编程规范","slug":"编程规范","permalink":"http://wangxun.date/tags/编程规范/"}]},{"title":"java排序算法","date":"2017-04-06T01:58:26.000Z","path":"2017/04/06/java排序算法/","text":"原文出处： csdn-a125138 分类： 插入排序（直接插入排序、希尔排序） 交换排序（冒泡排序、快速排序） 选择排序（直接选择排序、堆排序） 归并排序 分配排序（基数排序）所需辅助空间最多：归并排序所需辅助空间最少：堆排序平均速度最快：快速排序不稳定：快速排序，希尔排序，堆排序。 先来看看8种排序之间的关系： 直接插入排序 （1）基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。（2）实例（3）用java实现123456789101112131415public static void insertSort()&#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; int temp=0; for(int i=1;i&lt;a.length;i++)&#123; int j=i-1; temp=a[i]; for(;j&gt;=0&amp;&amp;temp&lt;a[j];j--)&#123; a[j+1]=a[j]; //将大于temp的值整体后移一个单位 &#125; a[j+1]=temp; &#125; for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125;&#125; 希尔排序（最小增量排序） （1）基本思想：算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。（2）实例：（3）用java实现12345678910111213141516171819202122232425public static void shellSort() &#123; int a[] = &#123;1, 54, 6, 3, 78, 34, 12, 45, 56, 100&#125;; double d1 = a.length; int temp = 0; while (true) &#123; d1 = Math.ceil(d1 / 2); int d = (int) d1; for (int x = 0; x &lt; d; x++) &#123; for (int i = x + d; i &lt; a.length; i += d) &#123; int j = i - d; temp = a[i]; for (; j &gt;= 0 &amp;&amp; temp &lt; a[j]; j -= d) &#123; a[j + d] = a[j]; &#125; a[j + d] = temp; &#125; &#125; if (d == 1) &#123; break; &#125; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; &#125;&#125; 简单选择排序 （1）基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。（2）实例：（3）用java实现12345678910111213141516171819public static void selectSort()&#123; int a[]=&#123;1,54,6,3,78,34,12,45&#125;; int position=0; for(int i=0;i&lt;a.length;i++)&#123; int j=i+1; position=i; int temp=a[i]; for(;j&lt;a.length;j++)&#123; if(a[j]&lt;temp)&#123; temp=a[j]; position=j; &#125; &#125; a[position]=a[i]; a[i]=temp; &#125; for(int i=0;i&lt;a.length;i++) System.out.println(a[i]);&#125; 堆排序 （1）基本思想：堆排序是一种树形选择排序，是对直接选择排序的有效改进。堆的定义如下：具有n个元素的序列（h1,h2,…,hn),当且仅当满足（hi&gt;=h2i,hi&gt;=2i+1）或（hi&lt;=h2i,hi&lt;=2i+1）(i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。（2）实例：初始序列：46,79,56,38,40,84建堆：交换，从堆中踢出最大数剩余结点再建堆，再交换踢出最大数依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。（3）用java实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void heapSort()&#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; System.out.println(\"开始排序\"); int arrayLength=a.length; //循环建堆 for(int i=0;i&lt;arrayLength-1;i++)&#123; //建堆 buildMaxHeap(a,arrayLength-1-i); //交换堆顶和最后一个元素 swap(a,0,arrayLength-1-i); System.out.println(Arrays.toString(a)); &#125;&#125;private void swap(int[] data, int i, int j) &#123; int tmp=data[i]; data[i]=data[j]; data[j]=tmp;&#125;//对data数组从0到lastIndex建大顶堆private void buildMaxHeap(int[] data, int lastIndex) &#123; // TODO Auto-generated method stub //从lastIndex处节点（最后一个节点）的父节点开始 for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123; //k保存正在判断的节点 int k=i; //如果当前k节点的子节点存在 while(k*2+1&lt;=lastIndex)&#123; //k节点的左子节点的索引 int biggerIndex=2*k+1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if(biggerIndex&lt;lastIndex)&#123; //若果右子节点的值较大 if(data[biggerIndex]&lt;data[biggerIndex+1])&#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if(data[k]&lt;data[biggerIndex])&#123; //交换他们 swap(data,k,biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k=biggerIndex; &#125;else&#123; break; &#125; &#125; &#125;&#125; 冒泡排序 （1）基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。（2）实例：（3）用java实现12345678910111213141516public static void bubbleSort()&#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; int temp=0; for(int i=0;i&lt;a.length-1;i++)&#123; for(int j=0;j&lt;a.length-1-i;j++)&#123; if(a[j]&gt;a[j+1])&#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125; for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125;&#125; 快速排序 （1）基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。（2）实例：（3）用java实现1234567891011121314151617181920212223242526272829303132public static void quick() &#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; if (a.length &gt; 0) &#123; //查看数组是否为空 _quickSort(a,0, a.length - 1); &#125; for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125;&#125;private static int getMiddle(int[] list, int low, int high) &#123; int tmp =list[low]; //数组的第一个作为中轴 while (low &lt; high)&#123; while (low &lt; high&amp;&amp; list[high] &gt;= tmp) &#123; high--; &#125; list[low] =list[high]; //比中轴小的记录移到低端 while (low &lt; high&amp;&amp; list[low] &lt;= tmp) &#123; low++; &#125; list[high] =list[low]; //比中轴大的记录移到高端 &#125; list[low] = tmp; //中轴记录到尾 return low; //返回中轴的位置&#125;private static void _quickSort(int[] list, int low, int high) &#123; if (low &lt; high)&#123; int middle =getMiddle(list, low, high); //将list数组进行一分为二 _quickSort(list, low, middle - 1); //对低字表进行递归排序 _quickSort(list,middle + 1, high); //对高字表进行递归排序 &#125;&#125; 归并排序 （1）基本排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。（2）实例：（3）用java实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void mergingSort()&#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; sort(a,0,a.length-1); for(int i=0;i&lt;a.length;i++) System.out.println(a[i]);&#125;private static void sort(int[] data, int left, int right) &#123; // TODO Auto-generatedmethod stub if(left&lt;right)&#123; //找出中间索引 int center=(left+right)/2; //对左边数组进行递归 sort(data,left,center); //对右边数组进行递归 sort(data,center+1,right); //合并 merge(data,left,center,right); &#125;&#125;private static void merge(int[] data, int left, int center, int right) &#123; // TODO Auto-generatedmethod stub int [] tmpArr= new int[data.length]; int mid=center+1; //third记录中间数组的索引 int third=left; int tmp=left; while(left&lt;=center&amp;&amp;mid&lt;=right)&#123; //从两个数组中取出最小的放入中间数组 if(data[left]&lt;=data[mid])&#123; tmpArr[third++]=data[left++]; &#125;else&#123; tmpArr[third++]=data[mid++]; &#125; &#125; //剩余部分依次放入中间数组 while(mid&lt;=right)&#123; tmpArr[third++]=data[mid++]; &#125; while(left&lt;=center)&#123; tmpArr[third++]=data[left++]; &#125; //将中间数组中的内容复制回原数组 while(tmp&lt;=right)&#123; data[tmp]=tmpArr[tmp++]; &#125; System.out.println(Arrays.toString(data));&#125; 基数排序 （1）基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。（2）实例： （3）用java实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void radixSort()&#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,101,56,17,18,23,34,15,35,25,53,51&#125;; sort(a); for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]); &#125;&#125;private static void sort(int[] array)&#123; //首先确定排序的趟数; int max=array[0]; for(int i=1;i&lt;array.length;i++)&#123; if(array[i]&gt;max)&#123; max=array[i]; &#125; &#125; int time=0; //判断位数; while(max&gt;0)&#123; max/=10; time++; &#125; //建立10个队列; List&lt;ArrayList&gt; queue=new ArrayList&lt;ArrayList&gt;(); for(int i=0;i&lt;10;i++)&#123; ArrayList&lt;Integer&gt;queue1=new ArrayList&lt;Integer&gt;(); queue.add(queue1); &#125; //进行time次分配和收集; for(int i=0;i&lt;time;i++)&#123; //分配数组元素; for(int j=0;j&lt;array.length;j++)&#123; //得到数字的第time+1位数; int x=array[j]%(int)Math.pow(10,i+1)/(int)Math.pow(10, i); ArrayList&lt;Integer&gt;queue2=queue.get(x); queue2.add(array[j]); queue.set(x, queue2); &#125; int count=0;//元素计数器; //收集队列元素; for(int k=0;k&lt;10;k++)&#123; while(queue.get(k).size()&gt;0)&#123; ArrayList&lt;Integer&gt;queue3=queue.get(k); array[count]=queue3.get(0); queue3.remove(0); count++; &#125; &#125; &#125;&#125;","tags":[{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"},{"name":"Java","slug":"Java","permalink":"http://wangxun.date/tags/Java/"},{"name":"排序","slug":"排序","permalink":"http://wangxun.date/tags/排序/"}]},{"title":"java数据类型","date":"2017-04-06T01:18:47.000Z","path":"2017/04/06/java数据类型/","text":"java数据类型 ┏数值型━┳━整数型：byte short int long ┏基本数据类型━━┫ ┗━浮点型：float double ┃ ┣字符型：char 数据类型╋ ┗布尔型：boolean ┃ ┏类（class） ┗引用数据类型━━╋接口（interface） ┗数组（array） java 八种基础数据类型；三种引用数据类型。第一类:整数型(byte、short、int、long) bytebyte由1个字节8位表示，是最小的整数类型。主要用于节省内存空间关键。当操作来自网络、文件或者其他IO的数据流时，byte类型特别有用。取值范围为:[-128, 127]. shortshort用16位表示，取值范围为：[- 2^15, 2^15 - 1]。short可能是最不常用的类型了。short类型参与运算的时候，一样被提升为int或者更高的类型。(-32768到32767) intInt 32 bits, [- 2^31, 2^31 - 1].有符号的二进制补码表示的整数。(-2147483648,到2147483647共10位)Integer是java为int提供的封装类int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况。例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer longLong 64 bits， [- 2^63, 2^63 - 1,默认值为0L].当需要计算非常大的数时，如果int不足以容纳大小，可以使用long类型。如果long也不够，可以使用BigInteger类。(-9223372036854775808到9223372036854775807共19位)声明Long型常量后需加L eg: long i = 8888888888888L; 第二类:文本型char Char16 bits, [0, 65535], [0, 2^16 -1],从’\\u0000’到’\\uffff’。无符号，默认值为’\\u0000’。Java使用Unicode字符集表示字符，Unicode是完全国 际化的字符集，可以表示全部人类语言中的字符。Unicode需要16位宽，所以Java中的char类型也使用16 bit表示。当char进行加减乘除运算的时候，也被转换成int类型，必须显式转化回来。 第三类:逻辑型boolean boolean取值只有true 或者 false， 默认为false。boolean与是否为0没有任何关系，但是可以根据想要的逻辑进行转换。 第四类:浮点型(float、double) float使用32 bits表示，对应单精度浮点数，运行速度相比double更快，占内存更小，但是当数值非常大或者非常小的时候会变得不精确。精度要求不高的时候可以使用float类型声明float型常量后需加f或者声明类型；12float c =(float) 11.1;float d = 11.1f; double使用64bits为表示，将浮点子面子赋给某个变量时，如果不显示在字面值后面加f或者F，则默认为double类型。java.lang.Math中的函数都采用double类型。如果double和float都无法达到想要的精度，可以使用BigDecimal类","tags":[{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"},{"name":"Java","slug":"Java","permalink":"http://wangxun.date/tags/Java/"},{"name":"数据类型","slug":"数据类型","permalink":"http://wangxun.date/tags/数据类型/"}]},{"title":"线程并发时，控制执行顺序","date":"2017-04-05T06:29:09.000Z","path":"2017/04/05/线程并发时，控制执行顺序/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.mengyanxin.utils.thread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class TestThread &#123; public static void main(String[] args) &#123; final Print pt = new Print(); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 1; i &lt;= 3; i++) &#123; pt.printA(i); &#125; &#125; &#125;,\"A\").start(); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 1; i &lt;= 3; i++) &#123; pt.printB(i); &#125; &#125; &#125;,\"B\").start(); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 1; i &lt;= 3; i++) &#123; pt.printC(i); System.out.println(\"-----------------------------------\"); &#125; &#125; &#125;,\"C\").start(); &#125;&#125;class Print &#123; private int number = 1; private Lock lock = new ReentrantLock(); private Condition conditionA = lock.newCondition(); private Condition conditionB = lock.newCondition(); private Condition conditionC = lock.newCondition(); public void printA(int count)&#123; try &#123; lock.lock(); if (number != 1) &#123; conditionA.await(); &#125; for (int i = 0; i &lt; 1; i++) &#123; System.out.println(Thread.currentThread().getName()+ \"\\t\" + i + \"\\t\" + \"第\" + count +\"轮\"); &#125; number = 2; conditionB.signal(); &#125; catch (Exception e) &#123; &#125;finally&#123; lock.unlock(); &#125; &#125; public void printB(int count)&#123; try &#123; lock.lock(); if (number != 2) &#123; conditionB.await(); &#125; for (int i = 0; i &lt; 1; i++) &#123; System.out.println(Thread.currentThread().getName()+ \"\\t\" + i + \"\\t\" + \"第\" + count +\"轮\"); &#125; number = 3; conditionC.signal(); &#125; catch (Exception e) &#123; &#125;finally&#123; lock.unlock(); &#125; &#125; public void printC(int count)&#123; try &#123; lock.lock(); if (number != 3) &#123; conditionC.await(); &#125; for (int i = 0; i &lt; 1; i++) &#123; System.out.println(Thread.currentThread().getName()+ \"\\t\" + i + \"\\t\" + \"第\" + count +\"轮\"); &#125; number = 1; conditionA.signal(); &#125; catch (Exception e) &#123; &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 输出结果： A 0 第1轮B 0 第1轮C 0 第1轮 A 0 第2轮B 0 第2轮C 0 第2轮 A 0 第3轮B 0 第3轮C 0 第3轮","tags":[{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"},{"name":"Java","slug":"Java","permalink":"http://wangxun.date/tags/Java/"},{"name":"thread","slug":"thread","permalink":"http://wangxun.date/tags/thread/"}]},{"title":"十进制转二进制计算方法","date":"2017-04-05T01:52:46.000Z","path":"2017/04/05/十进制转二进制计算方法/","text":"十进制整数转换为二进制整数采用”除2取余，逆序排列”法。 具体做法是：用2去除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为0时为止。然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。 举例来说： 整数87转换为二进制：87÷2=43 余143÷2=21 余121÷2=10 余110÷2= 5 余05 ÷2= 2 余12 ÷2= 1 余01 ÷2= 0 余1从下往上取余数1010111。所以，87[10]=1010111[2]. 小数36.75转换为二进制这个要分开成36和0.75来算36÷2=18 余018÷2= 9 余09 ÷2= 4 余14 ÷2= 2 余02 ÷2= 1 余01 ÷2= 0 余1则36的二进制数为100100 2*5+2*2=32+4=360.75*2=1.5 取1，余0.50.5 *2=1 取1，余0则0.75的二进制数为0.1136.75的二进制数为100100.11","tags":[{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"},{"name":"Java","slug":"Java","permalink":"http://wangxun.date/tags/Java/"},{"name":"进制转换","slug":"进制转换","permalink":"http://wangxun.date/tags/进制转换/"}]},{"title":"Java进制转换方法","date":"2017-03-31T08:22:05.000Z","path":"2017/03/31/Java进制转换方法/","text":"方法调用及结果 12345678910111213141516171819202122public static void main(String[] args)&#123; int x = 128; String value; //十进制转成十六进制 value = Integer.toHexString(x); System.out.println(value);//80 //十进制转成八进制 value = Integer.toOctalString(x); System.out.println(value);//200 //十进制转成二进制 value = Integer.toBinaryString(x); System.out.println(value);//10000000 //十六进制转成十进制 value = Integer.valueOf(\"FFFF\",16).toString(); System.out.println(value);//65535 //八进制转成十进制 value = Integer.valueOf(\"776\",8).toString(); System.out.println(value);//510 //二进制转十进制 value = Integer.valueOf(\"0101\",2).toString(); System.out.println(value);//5&#125;","tags":[{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"},{"name":"Java","slug":"Java","permalink":"http://wangxun.date/tags/Java/"},{"name":"进制转换","slug":"进制转换","permalink":"http://wangxun.date/tags/进制转换/"}]},{"title":"Java位运算符","date":"2017-03-31T08:08:47.000Z","path":"2017/03/31/Java位运算符/","text":"位运算符主要针对二进制数的位进行逻辑运算，主要包括：与(&amp;)、或(|)、非(~)、异或(^) 最高位为0代表正数，最高位为1的代表负数 原码就是符号位加上真值的绝对值，即用第一位表示符号, 其余位表示值; 正数的反码 = 补码 = 原码 负数的反码是在其原码的基础上,符号位不变，其余各个位取反; 负数的补码=在其原码的基础上,符号位不变, 其余各位取反, 最后+1.(即在反码的基础上+1) 已知一个数的补码，求原码的操作分两种情况： 如果补码的符号位为“0”，表示是一个正数，所以补码就是该数的原码。 如果补码的符号位为“1”，表示是一个负数，求原码的操作可以是：符号位为1，其余各位取反，然后再整个数加1。 与运算符(&amp;) 正数和正数两个操作数中位都为1，结果才为1，否则结果为0。1234567public static void main(String[] args)&#123; int x=129; System.out.println(Integer.toBinaryString(x));//10000001 int y=128; System.out.println(Integer.toBinaryString(y));//10000000 System.out.println(\"x&amp;y=\"+(x&amp;y));//x&amp;y=128&#125; 正数和负数1234567public static void main(String[] args)&#123; int x=5; System.out.println(Integer.toBinaryString(x)); int y=-3; System.out.println(Integer.toBinaryString(y)); System.out.println(\"x&amp;y=\"+(x&amp;y));//x&amp;y=5&#125; 计算流程： 5的二进制形式为： 0000 0101，（补码）-3的二进制形式为：1111 1101，（按位取反+1） （计算机是以补码的形式存储，用补码计算）计算结果为： 0000 0101 （正数，结果转化为原码 = 5）-5的二进制形式为：1111 1011，-3的二进制形式为：1111 1101，（按位取反+1） （计算机是以补码的形式存储，用补码计算）计算结果为： 1111 1001 （负数，结果转化为原码 （符号位不变，按位取反+1）1000 0111 = -7） 或运算符(|) 两个位只要有一个为1，那么结果就是1，否则就为0。1234567public static void main(String[] args)&#123; int x=129; System.out.println(Integer.toBinaryString(x));//10000001 int y=128; System.out.println(Integer.toBinaryString(y));//10000000 System.out.println(\"x|y=\"+(x|y));//x|y=129&#125; 非运算符(~) 如果位为0，结果是1，如果位为1，结果是0。12345678public static void main(String[] args)&#123; int x = 5; System.out.println(Integer.toBinaryString(x));//101 System.out.println(\"~x=\"+(~x));//~x=-6 int y = -5; System.out.println(Integer.toBinaryString(y));//11111111111111111111111111111011 System.out.println(\"~y=\"+(~y));//~y=4&#125;计算原理：5 转化为二进制是 0000 0101，~运算规则是按位取反，那么为 1111 1010，此时仍为补码，是计算机系统的存储模式，我们需要的结果是需要将补码化为原码，换算过程：按位取反10000101 再整个+1，故原码为1000 0110 = -6（最高位为负，二进制转化为十进制为6） 异或运算符(^) 两个操作数的位中，相同则结果为0，不同则结果为1。12345public static void main(String[] args)&#123; int x = 15; int y = 2; System.out.println(\"x^y=\"+(a^b));//x^y=13&#125;分析上面的程序段：a 的值是15，转换成二进制为1111，而b 的值是2，转换成二进制为0010，根据异或的运算规律，可以得出其结果为1101 即13。 位移运算符(&gt;&gt;、&lt;&lt;) &lt;&lt; (左移) 左移就是向左移位，如果要移动2位那么前面删掉2个0最后面补2个0（注意：前面删两个0只能是在0的前面没有1的地方才可以删）12345678public static void main(String[] args)&#123; int x = 3; System.out.println(x&lt;&lt;2);//12 System.out.println(x&gt;&gt;2);//0 int y = -3; System.out.println(y&lt;&lt;2);//-12 System.out.println(y&gt;&gt;2);//-1&#125;一个数m左移n位，结果为m乘以2的n次方一个数m右移n位，结果为m除以2的n次方","tags":[{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"},{"name":"Java","slug":"Java","permalink":"http://wangxun.date/tags/Java/"},{"name":"位运算符","slug":"位运算符","permalink":"http://wangxun.date/tags/位运算符/"}]},{"title":"Java两整形变量互换值","date":"2017-03-31T07:25:35.000Z","path":"2017/03/31/Java两整形变量互换值/","text":"利用第三个临时变量 123456789public static void main(String[] args)&#123; int x=10,y=20; int temp = x; x = y; y=temp; System.out.println(\"x=\"+x+\",y=\"+y);&#125;//输出x=20,y=10 使用两个数的和作为中间变量 ps:缺点是两个数值的和可能超过类型的最大值123456789public static void main(String[] args)&#123; int x=10,y=20; x = x + y; y = x - y; x = x - y; System.out.println(\"x=\"+x+\",y=\"+y);&#125;//输出x=20,y=10 利用位运算符(^)异或 原理：一个数异或同一个数两次，结果还是这个数本身123456789public static void main(String[] args)&#123; int x=10,y=20; x = x ^ y; y = x ^ y; //y=(x^y)^y,将x的值赋给y x = x ^ y; //x=x^(x^y),这是的y的值为x的最初值10，x的值为(10^20) System.out.println(\"x=\"+x+\",y=\"+y);&#125;//输出x=20,y=10","tags":[{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"},{"name":"Java","slug":"Java","permalink":"http://wangxun.date/tags/Java/"},{"name":"换位","slug":"换位","permalink":"http://wangxun.date/tags/换位/"}]},{"title":"Atom常用快捷键","date":"2017-03-30T06:18:58.000Z","path":"2017/03/30/Atom常用快捷键/","text":"组合键 功能 Crtl+Shift+M 开启Markdown实时预览 Command+Shift+P 打开命令窗口，可以运行各种菜单功能 Command + T 快速多文件切换 Command + F 文件内查找和替换 Command + Shift + F 多文件查找和替换 Command + [ 对选中内容向左缩进 Command + ] 对选中内容向右缩进 Content Cell Content Cell 文件切换ctrl-shift-s 保存所有打开的文件cmd-shift-o 打开目录cmd-\\ 显示或隐藏目录树ctrl-0 焦点移到目录树目录树下，使用a，m，delete来增加，修改和删除cmd-t或cmd-p 查找文件cmd-b 在打开的文件之间切换cmd-shift-b 只搜索从上次git commit后修改或者新增的文件 导航（等价于上下左右）ctrl-p 前一行ctrl-n 后一行ctrl-f 前一个字符ctrl-b 后一个字符 alt-B, alt-left 移动到单词开始alt-F, alt-right 移动到单词末尾 cmd-right, ctrl-E 移动到一行结束cmd-left, ctrl-A 移动到一行开始 cmd-up 移动到文件开始cmd-down 移动到文件结束 ctrl-g 移动到指定行 row:column 处 cmd-r 在方法之间跳转 书签cmd-F2 在本行增加书签F2 跳到当前文件的下一条书签shift-F2 跳到当前文件的上一条书签ctrl-F2 列出当前工程所有书签 选取大部分和导航一致，只不过加上shiftctrl-shift-P 选取至上一行ctrl-shift-N 选取至下一样ctrl-shift-B 选取至前一个字符ctrl-shift-F 选取至后一个字符alt-shift-B, alt-shift-left 选取至字符开始alt-shift-F, alt-shift-right 选取至字符结束ctrl-shift-E, cmd-shift-right 选取至本行结束ctrl-shift-A, cmd-shift-left 选取至本行开始cmd-shift-up 选取至文件开始cmd-shift-down 选取至文件结尾cmd-A 全选cmd-L 选取一行，继续按回选取下一行ctrl-shift-W 选取当前单词 编辑和删除文本基本操作ctrl-T 使光标前后字符交换cmd-J 将下一行与当前行合并ctrl-cmd-up, ctrl-cmd-down 使当前行向上或者向下移动cmd-shift-D 复制当前行到下一行cmd-K, cmd-U 使当前字符大写cmd-K, cmd-L 使当前字符小写 删除和剪切ctrl-shift-K 删除当前行cmd-backspace 删除到当前行开始cmd-fn-backspace 删除到当前行结束ctrl-K 剪切到当前行结束alt-backspace 或 alt-H 删除到当前单词开始alt-delete 或 alt-D 删除到当前单词结束 多光标和多处选取cmd-click 增加新光标cmd-shift-L 将多行选取改为多行光标ctrl-shift-up, ctrl-shift-down 增加上（下）一行光标cmd-D 选取文档中和当前单词相同的下一处ctrl-cmd-G 选取文档中所有和当前光标单词相同的位置 括号跳转ctrl-m 相应括号之间，html tag之间等跳转ctrl-cmd-m 括号(tag)之间文本选取alt-cmd-. 关闭当前XML/HTML tag 编码方式ctrl-shift-U 调出切换编码选项 查找和替换cmd-F 在buffer中查找cmd-shift-f 在整个工程中查找 代码片段alt-shift-S 查看当前可用代码片段在~/.atom目录下snippets.cson文件中存放了你定制的snippets定制说明 自动补全ctrl-space 提示补全信息 折叠alt-cmd-[ 折叠alt-cmd-] 展开alt-cmd-shift-{ 折叠全部alt-cmd-shift-} 展开全部cmd-k cmd-N 指定折叠层级 N为层级数 文件语法高亮ctrl-shift-L 选择文本类型 使用Atom进行写作ctrl-shift-M Markdown预览可用代码片段 b, legal, img, l, i, code, t, table","tags":[{"name":"Atom","slug":"Atom","permalink":"http://wangxun.date/tags/Atom/"},{"name":"editpad","slug":"editpad","permalink":"http://wangxun.date/tags/editpad/"},{"name":"markdown","slug":"markdown","permalink":"http://wangxun.date/tags/markdown/"},{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"}]},{"title":"markdown常用语法","date":"2017-03-30T06:16:58.000Z","path":"2017/03/30/markdown常用语法/","text":"常用语法示例区块元素标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1This is an H2任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 这是 H1这是 H2这是 H6区块引用 BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： This is the first level of quoting. This is nested blockquote. Back to the first level.引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： Red Green Blue等同于： Red Green Blue也等同于： Red Green Blue有序列表则使用数字接着一个英文句点： Bird McHale Parish如果要在列表项目内放进引用，那 `&gt;`` 就需要缩进： A list item with a blockquote: This is a blockquoteinside a list item.代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 和 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 区段元素链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is an example inline link. This link has no title attribute.如果你是要链接到同样主机的资源，你可以使用相对路径： See my About page for details.参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is an example reference-style link.你也可以选择性地在两个方括号中间加上一个空格： This is an example reference-style link.接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 下面是一个参考式链接的范例： I get 10 times more traffic from Google than fromYahoo or MSN. 如果改成用链接名称的方式写： I get 10 times more traffic from Google than fromYahoo or MSN. 强调 Markdown 使用星号（*）和底线（）作为标记强调字词的符号，被 或 包围的字词会被转成用 标签包围，用两个 或 _ 包起来的话，则会被转成 ，例如： single asterisks single underscores double asterisks double underscores代码 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the printf() function.如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： There is a literal backtick (`) here.代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don’t use any &lt;blink&gt; tags.你也可以这样写： &amp;#8212; is the decimal-encoded equivalent of &amp;mdash;.图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。参考式的图片语法则长得像这样： 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的标签。 本地图片上传 登陆http://yotuku.cn/上传图片，点击markdown，粘贴到markdown文档即可GFMGitHub用”GitHub Flavored Markdown”，简称GFM。它广泛应用在site–in issues, comments, 以及pull requests.它和标准的Markdown有一些区别，并添加了一些额外的功能。 与标准Markdown的区别下划线 标准Markdown将含有下划线的单词转成斜体字，而GFM忽略单词中的下划线。 删除线 GFM增加了删除线 Mistaken text.显示为：Mistaken text. 代码块 如果有一整块代码需要包围， 可以使用1例如： x = 0x = 2 + 2what is x12345678语法高亮代码块可以使用语法高亮了！！在你的代码块中添加一个可选的语言标识符,我们会通过语法高亮显示运行它。例如，为了语法高亮ruby代码：```rubyrequire 'redcarpet'markdown = Redcarpet.new(\"Hello World!\")puts markdown.to_html Github使用Linguist来实现语言检测和语法高亮。你可以通过阅读the languages YAML file.来获取有效的语法高亮关键字。 表格 你可以创建表格，通过符号-分开第一行和其他行，通过|分开各个列 First Header Second Header Content Cell Content Cell Content Cell Content Cell 在标题行包含:，你可以使得表格向左对齐，向右对齐，居中 Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 A colon on the left-most side indicates a left-aligned column; a colon on the right-most side indicates a right-aligned column; a colon on both sides indicates a center-aligned column.:在最左边表示左对齐，:在最右边表示右对齐，左右两边都有:表示居中。","tags":[{"name":"editpad","slug":"editpad","permalink":"http://wangxun.date/tags/editpad/"},{"name":"markdown","slug":"markdown","permalink":"http://wangxun.date/tags/markdown/"},{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"}]},{"title":"Atom常用插件","date":"2017-03-30T06:15:58.000Z","path":"2017/03/30/Atom常用插件/","text":"minimap language-markdown markdown-scroll-sync markdown-table-formatter markdown-write pretty-json","tags":[{"name":"Atom","slug":"Atom","permalink":"http://wangxun.date/tags/Atom/"},{"name":"editpad","slug":"editpad","permalink":"http://wangxun.date/tags/editpad/"},{"name":"markdown","slug":"markdown","permalink":"http://wangxun.date/tags/markdown/"},{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"}]},{"title":"搭建hexo+github个人博客","date":"2017-03-30T06:15:58.000Z","path":"2017/03/30/搭建hexo-github个人博客/","text":"创建GitHub仓库 注册/登陆创建仓库仓库名称必须为：用户名.github.io 安装Git 安装Git客户端安装Nodejs安装Hexo在命令行中输入:1npm install hexo-cli -g 创建本地博客 打开命令，定位到放置博客的文件夹下 输入命令：1hexo init 你的用户名.github.io // 建议和创建仓库时使用同一个 主题安装Next/yilia 切换到上面生成的博客本地目录(xxx.github.io)执行命令：12git clone https://github.com/iissnan/hexo-theme-next themes/nextgit clone git@github.com:litten/hexo-theme-yilia.git themes/yilia想要使用哪种主题，就下载哪一种主题 使用主题 切换到上面生成的博客本地目录(xxx.github.io)修改_config.yml文件1theme: next //刚刚安装的主题名称 注意：该配置文件中的键值之间一定要有空格，否则轻则没有作用，重则报错，无法启动。 配置文件基本项修改 请参考Hexo官方文档我自己的配置为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: mengyanxinsubtitle: 有情者伤人，无情者自伤description: 一人吃饱，全家不饿的小码农！author: mengyanxinlanguage: zh-Hansemail: 13260695212@163.comkeywords: \"java,liunx,html,js\"timezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 20pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia#theme: next#theme: landscape# 头像# 注意：是 xxx.github.io/source 下的开始的相对路径，如果 source 文件夹下面没有 uploads 文件夹，那么新建一个。考虑到会博客中用很多图片，在 uploads 文件夹下请分好类，避免混乱avatar: uploads/user/images/mengyan.jpg# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: http://github.com/mengyanxin/mengyanxin.github.io.gitjsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 运行本地服务 切换到博客本地目录(xxx.github.io)输入命令：1hexo s -p 5000 //可以直接使用hexo s打开服务如果PC已经安装福昕阅读器，会占用hexo的默认端口4000，使用-p 打开另一端口，供hexo使用 插件配置 切换的博客本地目录(xxx.github.io/themes/yilia)修改_config.yml文件下面是我的博客的配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# Headermenu: 主页: / 夢魇: /tags/mengyan 相册: /photos# SubNavsubnav: github: \"https://github.com/mengyanxin\" #weibo: \"http://weibo.com/litten225\" #rss: /atom.xml #zhihu: \"#\" #douban: \"#\" #segmentfault: \"#\" #mail: \"mailto:litten225@qq.com\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"#rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root:# Contentexcerpt_link: 'more'show_all_link: '展开全文'fancybox: truemathjax: false# 打赏reward_type: 2reward_wording: '谢谢你请我吃糖果'alipay: /assets/img/alipay.jpgweixin: /assets/img/weixin.jpg# 是否在新窗口打开链接open_in_new: true# Miscellaneousbaidu_analytics: 'a30844fa2bcbce0a9e001fe06cefeddf'google_analytics: falsefavicon: /assets/img/favicon.ico#你的头像urlavatar: /uploads/user/images/mengyan.jpg#是否开启分享share_jia: truemobile: social: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论#duoshuo: \"litten-hexo\"# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: '#4d4d4d' # 右滑板块背景 slider: 'linear-gradient(200deg,#a0cfe4,#e8c37e)'# slider的设置slider: # 是否默认展开tags板块 showTags: false# 如不需要，将该项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' friends: '友链' aboutme: '关于我'friends: alanli7991's Blog: http://alanli7991.github.io litten: http://litten.me 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 萌萌哒小菜鸡。。。 hexo常用命令 创建分类和标签页面12hexo new page categories //新建分类hexo new page tags //新建标签 编辑新建页面文件夹下面的index.md123456---title: All tagsdate: 2017-03-23 14:12:52type: \"categories\"comments: false---123456---title: All tagsdate: 2017-03-23 14:12:52type: \"tags\"comments: false--- 安装自动部署工具 切换到本地博客目录运行命令：1npm install hexo-deployer-git --save 部署到GitHubPages 123456hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署#也可以一次性执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d","tags":[{"name":"mengyan","slug":"mengyan","permalink":"http://wangxun.date/tags/mengyan/"},{"name":"github","slug":"github","permalink":"http://wangxun.date/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://wangxun.date/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://wangxun.date/tags/blog/"}]}]